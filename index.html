<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SKT Study</title>
  <meta name="theme-color" content="#F6F8FB" />
  <link rel="manifest" href="manifest.webmanifest" />
  <style>
    :root{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;

      /* Light (PDG-like) */
      --bg:#F6F8FB;
      --text:#111827;
      --muted:#6B7280;
      --surface:#FFFFFF;
      --surface2:#F9FAFB;
      --border:#E5E7EB;
      --border2:#D1D5DB;
      --headerBg: rgba(246,248,251,.88);
      --shadow: rgba(17,24,39,.08);
      --primary:#1E4FA8;
      --primaryText:#FFFFFF;
      --progress:#1E4FA8;
      --dangerBorder:#FCA5A5;
      --dangerBg:#FFF1F2;
      --okBorder:#86EFAC;
      --okBg:#ECFDF5;
      --link:#1E4FA8;
      --tabBg:#FFFFFF;
      --tabActiveBg:#EEF2FF;
      --pillBg:#FFFFFF;

      --btnBg:#1E4FA8;
      --btnText:#FFFFFF;
      --btnBorder:#1E4FA8;

      --btnSecondaryBg:#FFFFFF;
      --btnSecondaryText:#111827;
      --btnSecondaryBorder:#D1D5DB;
    }

    /* Softer Dark */
    html[data-theme="dark"]{
      --bg:#0F141B;
      --text:#E5E7EB;
      --muted:#9CA3AF;
      --surface:#141B24;
      --surface2:#101721;
      --border:#223041;
      --border2:#2B3B50;
      --headerBg: rgba(15,20,27,.86);
      --shadow: rgba(0,0,0,.35);
      --primary:#4B86FF;
      --primaryText:#081018;
      --progress:#4B86FF;
      --dangerBorder:#7F1D1D;
      --dangerBg:#1A1010;
      --okBorder:#14532D;
      --okBg:#0E1712;
      --link:#7FB2FF;
      --tabBg:#101721;
      --tabActiveBg:#162236;
      --pillBg:#101721;

      --btnBg:#4B86FF;
      --btnText:#081018;
      --btnBorder:#4B86FF;

      --btnSecondaryBg:#101721;
      --btnSecondaryText:#E5E7EB;
      --btnSecondaryBorder:#2B3B50;
    }

    body { margin: 0; background:var(--bg); color:var(--text); }
    header {
      padding: 14px 16px;
      position: sticky; top: 0;
      background:var(--headerBg);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
      z-index: 5;
    }
    h1 { margin: 0; font-size: 16px; font-weight: 800; letter-spacing: .2px; }
    main { padding: 14px 16px 112px; max-width: 920px; margin: 0 auto; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    button, select, input[type="file"], input[type="text"], input[type="number"] {
      background:var(--btnSecondaryBg);
      color:var(--btnSecondaryText);
      border: 1px solid var(--btnSecondaryBorder);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 650;
      -webkit-tap-highlight-color: transparent;
    }
    button.primary{
      background:var(--btnBg);
      color:var(--btnText);
      border:1px solid var(--btnBorder);
    }
    button:active { transform: scale(0.99); }
    input[type="text"], input[type="number"] { font-weight: 600; }

    .card {
      margin-top: 14px;
      padding: 16px;
      border: 1px solid var(--border);
      background:var(--surface);
      border-radius: 18px;
      box-shadow: 0 6px 18px var(--shadow);
    }
    .muted { color:var(--muted); font-size: 13px; }
    .pill {
      display:inline-flex; gap:6px; align-items:center;
      padding: 6px 10px; border-radius: 999px;
      border:1px solid var(--border);
      background:var(--pillBg);
      font-weight: 650;
    }
    .tabs { display:flex; gap:8px; margin-top: 10px; overflow:auto; -webkit-overflow-scrolling: touch; padding-bottom: 2px; }
    .tab {
      padding: 8px 12px; border-radius: 999px;
      border:1px solid var(--border2);
      background:var(--tabBg);
      cursor:pointer; user-select:none; white-space:nowrap;
      color: var(--text);
      font-weight: 650;
      flex: 0 0 auto;
    }
    .tab.active { border-color:var(--primary); background:var(--tabActiveBg); }
    .big { font-size: 18px; font-weight: 850; }
    .chunk { white-space: pre-wrap; line-height: 1.45; }
    .actions { display:flex; gap:10px; margin-top: 12px; flex-wrap:wrap; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(230px, 1fr)); gap: 12px; }
    .stat { padding: 12px; border-radius: 16px; border:1px solid var(--border); background:var(--surface2); }
    .danger { border-color:var(--dangerBorder); background:var(--dangerBg); }
    .ok { border-color:var(--okBorder); background:var(--okBg); }
    a { color:var(--link); }

    footerNav {
      position: fixed; bottom: 0; left: 0; right: 0;
      background:var(--headerBg);
      backdrop-filter: blur(10px);
      border-top: 1px solid var(--border);
      padding: 10px 12px;
      display:flex; justify-content:center;
      z-index: 5;
    }
    footerNav .row { max-width:920px; width:100%; justify-content:space-between; align-items:center; }
    .smallBtn { padding: 8px 10px; border-radius: 12px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; padding: 2px 6px; border-radius: 8px; border:1px solid var(--border2); background:var(--surface2); color:var(--text); }

    .progressWrap { margin-top: 10px; border:1px solid var(--border2); border-radius: 999px; overflow:hidden; }
    .progressBar { height: 10px; background:var(--progress); width: 0%; }
    .badge { display:inline-flex; align-items:center; gap:8px; padding: 8px 10px; border-radius: 14px; border:1px solid var(--border2); background:var(--surface2); font-weight: 650; }

    /* Toggle */
    .toggleRow{display:flex;align-items:center;gap:10px}
    .switch{position:relative;display:inline-block;width:44px;height:26px}
    .switch input{opacity:0;width:0;height:0}
    .slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:var(--border2);transition:.2s;border-radius:999px}
    .slider:before{position:absolute;content:"";height:20px;width:20px;left:3px;bottom:3px;background:var(--surface);transition:.2s;border-radius:999px;border:1px solid var(--border)}
    .switch input:checked + .slider{background:var(--primary)}
    .switch input:checked + .slider:before{transform:translateX(18px)}
  </style>

  <!-- PDF.js for client-side PDF text extraction -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
<header>
  <div class="row" style="justify-content:space-between">
    <h1>SKT Study</h1>
    <div class="row" style="gap:8px">
      <span class="pill">XP <span id="xpTop">0</span></span>
      <span class="pill">Lvl <span id="lvlTop">1</span></span>
    </div>
  </div>

  <div class="tabs" role="tablist" aria-label="Sections">
    <div class="tab active" data-tab="home">Home</div>
    <div class="tab" data-tab="study">Study</div>
    <div class="tab" data-tab="quiz">Quiz</div>
    <div class="tab" data-tab="library">Library</div>
    <div class="tab" data-tab="stats">Stats</div>
    <div class="tab" data-tab="settings">Settings</div>
  </div>
</header>

<main>
  <div id="home" class="panel"></div>
  <div id="study" class="panel" style="display:none"></div>
  <div id="quiz" class="panel" style="display:none"></div>
  <div id="library" class="panel" style="display:none"></div>
  <div id="stats" class="panel" style="display:none"></div>
  <div id="settings" class="panel" style="display:none"></div>
</main>

<footerNav>
  <div class="row">
    <span class="pill"><span id="countCards">0</span> cards</span>
    <span class="pill">Streak: <span id="streak">0</span></span>
    <span class="pill">Due: <span id="dueCount">0</span></span>
    <span class="pill">Today: <span id="dailyDone">0</span>/40</span>
    <button class="smallBtn" id="resetBtn" title="Reset progress (keeps imported text)">Reset Progress</button>
  </div>
</footerNav>

<script>
const LS_KEY = "sktStudy_v5";
const DAILY_GOAL_DEFAULT = 40;
const now = () => Date.now();

function defaultState() {
  return {
    docs: [],
    cards: [],
    prefs: {
      activeDocId: "",
      flip: false,
      minChunkSize: 350,
      maxChunkSize: 900,
      theme: "light"
    },
    stats: { streak: 0, lastStudyDay: "" },
    game: {
      xp: 0,
      dailyDone: 0,
      dailyGoal: DAILY_GOAL_DEFAULT,
      lastDailyDay: "",
      badges: {}
    }
  };
}

function loadState() {
  try {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return defaultState();
    const s = JSON.parse(raw);
    const d = defaultState();
    return {
      ...d,
      ...s,
      prefs: { ...d.prefs, ...(s.prefs || {}) },
      stats: { ...d.stats, ...(s.stats || {}) },
      game: { ...d.game, ...(s.game || {}), badges: { ...(d.game.badges || {}), ...((s.game||{}).badges || {}) } }
    };
  } catch {
    return defaultState();
  }
}
function saveState(s) { localStorage.setItem(LS_KEY, JSON.stringify(s)); }

let state = loadState();

function applyTheme() {
  const theme = (state.prefs.theme === "dark") ? "dark" : "light";
  document.documentElement.setAttribute("data-theme", theme);
  const meta = document.querySelector('meta[name="theme-color"]');
  if (meta) meta.setAttribute("content", theme === "dark" ? "#0F141B" : "#F6F8FB");
}
applyTheme();

function uid(prefix="id") {
  return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}
function todayKey() {
  const d = new Date();
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;
}
function resetDailyIfNeeded() {
  const tk = todayKey();
  if (state.game.lastDailyDay !== tk) {
    state.game.dailyDone = 0;
    state.game.lastDailyDay = tk;
    saveState(state);
  }
}
function bumpStreak() {
  const tk = todayKey();
  if (state.stats.lastStudyDay === tk) return;

  const d = new Date();
  const y = new Date(d.getFullYear(), d.getMonth(), d.getDate()-1);
  const yk = `${y.getFullYear()}-${String(y.getMonth()+1).padStart(2,"0")}-${String(y.getDate()).padStart(2,"0")}`;

  if (state.stats.lastStudyDay === yk) state.stats.streak = (state.stats.streak || 0) + 1;
  else state.stats.streak = 1;

  state.stats.lastStudyDay = tk;
  saveState(state);
}
function calcLevelFromXP(xp) { return Math.floor((xp || 0) / 250) + 1; }
function awardXP(amount) {
  resetDailyIfNeeded();
  state.game.xp = (state.game.xp || 0) + amount;
  saveState(state);
}
function incrementDailyDone(n=1) {
  resetDailyIfNeeded();
  state.game.dailyDone = Math.max(0, (state.game.dailyDone || 0) + n);
  saveState(state);
}
function earnBadge(id) {
  if (!state.game.badges) state.game.badges = {};
  if (!state.game.badges[id]) {
    state.game.badges[id] = true;
    saveState(state);
  }
}
function evaluateBadges() {
  if (state.docs.length >= 1) earnBadge("first_import");
  if ((state.stats.streak || 0) >= 3) earnBadge("streak_3");
  const totalSeen = state.cards.reduce((a,c)=>a+(c.seen||0),0);
  if (totalSeen >= 100) earnBadge("review_100");
  if (totalSeen >= 500) earnBadge("review_500");
  const totalAttempts = state.cards.reduce((a,c)=>a+((c.correct||0)+(c.wrong||0)),0);
  const totalCorrect = state.cards.reduce((a,c)=>a+(c.correct||0),0);
  const acc = totalAttempts ? (totalCorrect / totalAttempts) : 0;
  if (totalAttempts >= 100 && acc >= 0.80) earnBadge("acc_80");
}

function activeDoc() {
  if (!state.prefs.activeDocId && state.docs[0]) {
    state.prefs.activeDocId = state.docs[0].id;
    saveState(state);
  }
  return state.docs.find(d => d.id === state.prefs.activeDocId) || null;
}
function setActiveDoc(docId) {
  state.prefs.activeDocId = docId;
  saveState(state);
  renderAll();
}
function cardsForDoc(docId) { return state.cards.filter(c => c.docId === docId); }
function dueCount() { return state.cards.filter(c => !c.dueAt || c.dueAt <= now()).length; }

function updateCounts() {
  evaluateBadges();
  resetDailyIfNeeded();

  document.getElementById("countCards").textContent = state.cards.length;
  document.getElementById("streak").textContent = state.stats.streak || 0;
  document.getElementById("dueCount").textContent = dueCount();
  document.getElementById("dailyDone").textContent = state.game.dailyDone || 0;

  const xp = state.game.xp || 0;
  const lvl = calcLevelFromXP(xp);
  document.getElementById("xpTop").textContent = xp;
  document.getElementById("lvlTop").textContent = lvl;
}

function resetProgress() {
  state.cards = state.cards.map(c => ({...c, ease: 2.5, dueAt: 0, seen: 0, correct: 0, wrong: 0}));
  state.prefs.flip = false;
  state.stats.streak = 0;
  state.stats.lastStudyDay = "";
  state.game.dailyDone = 0;
  state.game.lastDailyDay = todayKey();
  saveState(state);
  renderAll();
}
document.getElementById("resetBtn").addEventListener("click", resetProgress);

// Importers
async function extractPdfText(file) {
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  let text = "";
  for (let p = 1; p <= pdf.numPages; p++) {
    const page = await pdf.getPage(p);
    const content = await page.getTextContent();
    const strings = content.items.map(it => it.str);
    text += `\n\n=== Page ${p} ===\n` + strings.join(" ");
  }
  return text;
}
async function readTextFile(file) { return await file.text(); }

function chunkTextToCards(docId, rawText, minSize, maxSize) {
  const cleaned = rawText
    .replace(/\r/g, "")
    .replace(/[ \t]+/g, " ")
    .replace(/\n{3,}/g, "\n\n")
    .trim();

  const parts = cleaned.split(/\n\n+|=== Page \d+ ===/g).map(s => s.trim()).filter(Boolean);

  const cards = [];
  let buffer = "";

  function titleFrom(text) {
    const first = (text.split(/[.?!]\s/)[0] || text).trim();
    return first.slice(0, 90) || "Card";
  }
  function flushBuffer() {
    const b = buffer.trim();
    if (!b) return;
    cards.push({
      id: uid("card"),
      docId,
      title: titleFrom(b),
      body: b,
      ease: 2.5,
      dueAt: 0,
      seen: 0,
      correct: 0,
      wrong: 0,
    });
    buffer = "";
  }

  for (const part of parts) {
    const candidateLen = (buffer ? buffer.length + 2 : 0) + part.length;
    if (candidateLen <= maxSize) {
      buffer += (buffer ? "\n\n" : "") + part;
    } else {
      if (buffer) flushBuffer();
      if (part.length <= maxSize) {
        buffer = part;
      } else {
        for (let i = 0; i < part.length; i += (maxSize - 50)) {
          buffer = part.slice(i, i + (maxSize - 50));
          flushBuffer();
        }
      }
    }
  }
  flushBuffer();
  return cards;
}

// Scheduling
function pickNextCard(docId) {
  const list = cardsForDoc(docId);
  if (!list.length) return null;
  const due = list.filter(c => !c.dueAt || c.dueAt <= now());
  if (due.length) {
    due.sort((a,b) => (a.dueAt||0) - (b.dueAt||0));
    return due[0];
  }
  const sorted = [...list].sort((a,b) => (a.seen||0) - (b.seen||0));
  return sorted[0];
}
function schedule(card, rating) {
  const c = {...card};
  c.seen = (c.seen||0) + 1;
  if (rating === "again") {
    c.wrong = (c.wrong||0) + 1;
    c.ease = Math.max(1.3, (c.ease||2.5) - 0.2);
    c.dueAt = now() + 15 * 60 * 1000;
  } else {
    c.correct = (c.correct||0) + 1;
    c.ease = Math.min(3.2, (c.ease||2.5) + 0.05);
    const days = Math.max(1, Math.round(c.ease * (c.correct - c.wrong + 2)));
    c.dueAt = now() + days * 24 * 60 * 60 * 1000;
  }
  return c;
}
function upsertCard(updated) {
  const i = state.cards.findIndex(x => x.id === updated.id);
  if (i >= 0) state.cards[i] = updated;
  saveState(state);
}

function makeCloze(text) {
  const words = text.split(/\s+/).filter(Boolean);
  const candidates = words.map((w, idx) => ({ w: w.replace(/[^\w-]/g,""), idx }))
    .filter(x => x.w.length >= 6 && !/^\d+$/.test(x.w));
  if (!candidates.length) return null;
  const pick = candidates[Math.floor(candidates.length * 0.45)];
  const answer = pick.w;
  const masked = words.map((w,i) => (i === pick.idx ? "_____" : w)).join(" ");
  return { masked, answer };
}
function escapeHtml(s) {
  return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}

// Tabs
function switchTab(tab) {
  document.querySelectorAll(".tab").forEach(x => x.classList.remove("active"));
  const t = document.querySelector(`.tab[data-tab="${tab}"]`);
  if (t) t.classList.add("active");
  document.querySelectorAll(".panel").forEach(p => p.style.display = "none");
  document.getElementById(tab).style.display = "";
  renderAll();
}
document.querySelectorAll(".tab").forEach(t => t.addEventListener("click", () => switchTab(t.dataset.tab)));

function renderHome() {
  const el = document.getElementById("home");
  resetDailyIfNeeded();
  const goal = state.game.dailyGoal || DAILY_GOAL_DEFAULT;
  const done = state.game.dailyDone || 0;
  const pct = Math.min(100, Math.round((done / goal) * 100));
  const due = dueCount();
  const doc = activeDoc();
  const activeName = doc ? doc.name : "None";

  el.innerHTML = `
    <div class="card">
      <div class="big">Today's Mission</div>
      <div class="muted" style="margin-top:6px">Goal: <b>${goal}</b> questions ¬∑ Due now: <b>${due}</b></div>
      <div class="muted" style="margin-top:6px">Active: ${escapeHtml(activeName)}</div>
      <div class="progressWrap"><div class="progressBar" style="width:${pct}%"></div></div>
      <div class="muted" style="margin-top:8px">${done} / ${goal} complete (${pct}%)</div>
      <div class="actions">
        <button class="primary" id="startStudy">Start Studying</button>
        <button id="startQuiz">Quick Quiz</button>
        <button id="goLibrary">Import Doc</button>
      </div>
      <div class="muted" style="margin-top:10px">XP increases on every answer. Keep it simple: stack reps.</div>
    </div>
  `;
  document.getElementById("startStudy").onclick = () => switchTab("study");
  document.getElementById("startQuiz").onclick = () => switchTab("quiz");
  document.getElementById("goLibrary").onclick = () => switchTab("library");
}

function renderStudy() {
  const el = document.getElementById("study");
  const doc = activeDoc();
  if (!doc) {
    el.innerHTML = `<div class="card danger"><div class="big">No material imported yet</div>
      <div class="muted" style="margin-top:8px">Go to <b>Library</b> ‚Üí Import a PDF or text file.</div></div>`;
    return;
  }
  const next = pickNextCard(doc.id);
  if (!next) {
    el.innerHTML = `<div class="card"><div class="big">No cards for "${escapeHtml(doc.name)}"</div>
      <div class="muted" style="margin-top:8px">Go to <b>Library</b> ‚Üí Import to generate cards.</div></div>`;
    return;
  }
  const isFlipped = !!state.prefs.flip;

  el.innerHTML = `
    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="muted">Active: ${escapeHtml(doc.name)}</div>
          <div class="big" style="margin-top:6px">${escapeHtml(next.title)}</div>
        </div>
        <button id="flipBtn">${isFlipped ? "Hide" : "Show"}</button>
      </div>
      <div style="margin-top:12px" class="chunk">
        ${isFlipped ? escapeHtml(next.body) : "<span class='muted'>Tap <b>Show</b> to reveal the text</span>"}
      </div>
      <div class="actions">
        <button id="againBtn">Again</button>
        <button class="primary" id="goodBtn">Good</button>
      </div>
      <div class="muted" style="margin-top:10px">Seen: ${next.seen||0} ¬∑ Correct: ${next.correct||0} ¬∑ Wrong: ${next.wrong||0}</div>
    </div>
  `;

  document.getElementById("flipBtn").onclick = () => {
    state.prefs.flip = !state.prefs.flip;
    saveState(state);
    renderStudy();
  };

  document.getElementById("againBtn").onclick = () => {
    bumpStreak();
    incrementDailyDone(1);
    awardXP(2);
    upsertCard(schedule(next, "again"));
    renderAll();
  };

  document.getElementById("goodBtn").onclick = () => {
    bumpStreak();
    incrementDailyDone(1);
    awardXP(10);
    upsertCard(schedule(next, "good"));
    renderAll();
  };
}

function renderQuiz() {
  const el = document.getElementById("quiz");
  const doc = activeDoc();
  if (!doc) {
    el.innerHTML = `<div class="card danger"><div class="big">No material imported yet</div>
      <div class="muted" style="margin-top:8px">Import a PDF or text file first.</div></div>`;
    return;
  }
  const list = cardsForDoc(doc.id);
  if (!list.length) {
    el.innerHTML = `<div class="card"><div class="big">No cards available</div>
      <div class="muted" style="margin-top:8px">Go to <b>Library</b> ‚Üí Import to generate cards.</div></div>`;
    return;
  }

  const card = pickNextCard(doc.id) || list[0];
  const cloze = makeCloze(card.body);
  if (!cloze) {
    el.innerHTML = `<div class="card"><div class="big">Quiz not available for this card</div>
      <div class="muted" style="margin-top:8px">Try another card.</div>
      <button id="nextQ" style="margin-top:12px">Next</button></div>`;
    document.getElementById("nextQ").onclick = () => renderQuiz();
    return;
  }

  el.innerHTML = `
    <div class="card">
      <div class="muted">Cloze quiz ¬∑ ${escapeHtml(doc.name)}</div>
      <div class="big" style="margin-top:8px">${escapeHtml(card.title)}</div>
      <div class="chunk" style="margin-top:12px">${escapeHtml(cloze.masked)}</div>
      <div style="margin-top:12px" class="row">
        <input id="ans" style="flex:1; min-width:220px" placeholder="Type the missing word" />
        <button class="primary" id="checkBtn">Check</button>
      </div>
      <div id="feedback" class="muted" style="margin-top:10px"></div>
      <div class="actions"><button id="nextBtn">Next</button></div>
    </div>
  `;

  document.getElementById("checkBtn").onclick = () => {
    bumpStreak();
    incrementDailyDone(1);
    const guess = document.getElementById("ans").value.trim();
    const ok = guess.toLowerCase() === cloze.answer.toLowerCase();

    document.getElementById("feedback").innerHTML = ok ? "‚úÖ Correct" : `‚ùå Correct answer: <b>${escapeHtml(cloze.answer)}</b>`;
    awardXP(ok ? 10 : 2);

    upsertCard(schedule(card, ok ? "good" : "again"));
    renderAll();
  };

  document.getElementById("nextBtn").onclick = () => renderQuiz();
}

function renderLibrary() {
  const el = document.getElementById("library");
  const opts = state.docs.map(d => `<option value="${d.id}" ${state.prefs.activeDocId===d.id?"selected":""}>${escapeHtml(d.name)}</option>`).join("");

  el.innerHTML = `
    <div class="card">
      <div class="big">Import your SKT material</div>
      <div class="muted" style="margin-top:8px">PDF extraction happens on-device. Your docs are not uploaded anywhere by this app.</div>

      <div class="row" style="margin-top:12px">
        <input type="file" id="fileInput" accept=".pdf,.txt,.md" />
        <button class="primary" id="importBtn">Import</button>
      </div>

      <div class="row" style="margin-top:12px">
        <span class="muted">Active document</span>
        <select id="docSelect">${opts || ""}</select>
        <button id="deleteDocBtn">Delete Doc</button>
      </div>

      <div class="muted" style="margin-top:10px">
        Tip: import one doc first, then tweak chunk sizing in <b>Settings</b>.
      </div>
    </div>

    <div class="card">
      <div class="big">Documents</div>
      <div class="muted" style="margin-top:8px">Each import creates a new document and generates cards.</div>

      <div style="margin-top:12px" class="grid">
        ${state.docs.map(d => `
          <div class="stat">
            <div style="font-weight:750">${escapeHtml(d.name)}</div>
            <div class="muted">${new Date(d.createdAt).toLocaleString()}</div>
            <div class="muted" style="margin-top:8px">${cardsForDoc(d.id).length} cards</div>
            <div class="actions" style="margin-top:10px"><button data-open="${d.id}">Set Active</button></div>
          </div>
        `).join("") || `<div class="muted">No documents yet.</div>`}
      </div>
    </div>
  `;

  el.querySelectorAll("button[data-open]").forEach(btn => btn.onclick = () => setActiveDoc(btn.dataset.open));

  const docSelect = document.getElementById("docSelect");
  if (docSelect) docSelect.onchange = () => setActiveDoc(docSelect.value);

  document.getElementById("deleteDocBtn").onclick = () => {
    const doc = activeDoc();
    if (!doc) return;
    state.docs = state.docs.filter(d => d.id !== doc.id);
    state.cards = state.cards.filter(c => c.docId !== doc.id);
    state.prefs.activeDocId = state.docs[0]?.id || "";
    saveState(state);
    renderAll();
  };

  document.getElementById("importBtn").onclick = async () => {
    const fi = document.getElementById("fileInput");
    const file = fi.files && fi.files[0];
    if (!file) { alert("Choose a PDF, TXT, or MD file first."); return; }

    const name = file.name;
    let text = "";
    try {
      if (name.toLowerCase().endsWith(".pdf")) text = await extractPdfText(file);
      else text = await readTextFile(file);
    } catch (e) {
      console.error(e);
      alert("Could not read file. If it's a PDF, try exporting to TXT or a different PDF.");
      return;
    }

    const docId = uid("doc");
    state.docs.unshift({ id: docId, name, createdAt: now(), text });
    state.cards.push(...chunkTextToCards(docId, text, state.prefs.minChunkSize, state.prefs.maxChunkSize));
    state.prefs.activeDocId = docId;
    state.prefs.flip = false;
    earnBadge("first_import");

    saveState(state);
    renderAll();
  };
}

function renderStats() {
  const el = document.getElementById("stats");
  const totalCorrect = state.cards.reduce((a,c)=>a+(c.correct||0),0);
  const totalWrong = state.cards.reduce((a,c)=>a+(c.wrong||0),0);
  const totalAttempts = totalCorrect + totalWrong;
  const acc = totalAttempts ? Math.round(100 * totalCorrect / totalAttempts) : 0;

  const weakest = [...state.cards]
    .filter(c => (c.seen||0) >= 2)
    .sort((a,b) => ((b.wrong||0)/(b.seen||1)) - ((a.wrong||0)/(a.seen||1)))
    .slice(0, 8);

  const xp = state.game.xp || 0;
  const lvl = calcLevelFromXP(xp);
  const goal = state.game.dailyGoal || DAILY_GOAL_DEFAULT;
  const done = state.game.dailyDone || 0;
  const pct = Math.min(100, Math.round((done / goal) * 100));

  const badges = state.game.badges || {};
  const badgeList = [
    {id:"first_import", label:"üìò First import"},
    {id:"streak_3", label:"üî• 3-day streak"},
    {id:"review_100", label:"‚úÖ 100 reviews"},
    {id:"review_500", label:"üèÜ 500 reviews"},
    {id:"acc_80", label:"üéØ 80%+ accuracy (100+ attempts)"}
  ].filter(b => badges[b.id]);

  el.innerHTML = `
    <div class="card">
      <div class="big">Progress</div>
      <div class="grid" style="margin-top:12px">
        <div class="stat ok"><div class="muted">Accuracy</div><div class="big">${acc}%</div></div>
        <div class="stat"><div class="muted">Level</div><div class="big">${lvl}</div></div>
        <div class="stat"><div class="muted">XP</div><div class="big">${xp}</div></div>
        <div class="stat"><div class="muted">Today</div><div class="big">${done}/${goal}</div></div>
      </div>
      <div class="progressWrap"><div class="progressBar" style="width:${pct}%"></div></div>
      <div class="muted" style="margin-top:8px">${pct}% of daily goal</div>
    </div>

    <div class="card">
      <div class="big">Badges</div>
      <div class="muted" style="margin-top:8px">Lightweight milestones‚Äîjust enough to keep momentum.</div>
      <div class="row" style="margin-top:12px">
        ${badgeList.length ? badgeList.map(b => `<span class="badge">${escapeHtml(b.label)}</span>`).join("") : `<span class="muted">No badges yet. Import a doc and start grinding reps.</span>`}
      </div>
    </div>

    <div class="card">
      <div class="big">Weakest cards</div>
      <div class="muted" style="margin-top:8px">Based on wrong/seen ratio (minimum 2 attempts).</div>
      <div style="margin-top:12px" class="grid">
        ${weakest.map(c => `
          <div class="stat danger">
            <div style="font-weight:800">${escapeHtml(c.title)}</div>
            <div class="muted" style="margin-top:6px">Wrong: ${c.wrong||0} / Seen: ${c.seen||0}</div>
          </div>
        `).join("") || `<div class="muted">No weak cards yet‚Äîdo a few rounds in Study/Quiz.</div>`}
      </div>
    </div>
  `;
}

function renderSettings() {
  const el = document.getElementById("settings");
  const goal = state.game.dailyGoal || DAILY_GOAL_DEFAULT;
  const theme = (state.prefs.theme === "dark") ? "dark" : "light";

  el.innerHTML = `
    <div class="card">
      <div class="big">Settings</div>
      <div class="muted" style="margin-top:8px">Light mode by default with a softer dark mode toggle.</div>

      <div class="row" style="margin-top:12px; justify-content:space-between">
        <div>
          <div style="font-weight:750">Theme</div>
          <div class="muted">${theme === "dark" ? "Dark (soft)" : "Light (default)"}</div>
        </div>
        <div class="toggleRow">
          <span class="muted">Light</span>
          <label class="switch">
            <input id="themeToggle" type="checkbox" ${theme==="dark"?"checked":""}/>
            <span class="slider"></span>
          </label>
          <span class="muted">Dark</span>
        </div>
      </div>

      <div class="muted" style="margin-top:14px">Adjust chunk sizing to make cards feel more like ‚Äúslides‚Äù.</div>

      <div class="row" style="margin-top:12px">
        <span class="muted">Min chunk</span>
        <input id="minChunk" type="number" min="150" max="1200" value="${state.prefs.minChunkSize}">
        <span class="muted">Max chunk</span>
        <input id="maxChunk" type="number" min="250" max="2500" value="${state.prefs.maxChunkSize}">
      </div>

      <div class="row" style="margin-top:12px">
        <span class="muted">Daily goal</span>
        <input id="dailyGoal" type="number" min="5" max="300" value="${goal}">
        <button class="primary" id="saveSettings">Save</button>
      </div>

      <div class="muted" style="margin-top:10px">
        Recommended: <span class="kbd">Min 350</span> / <span class="kbd">Max 900</span>.
      </div>
    </div>

    <div class="card danger">
      <div class="big">Rebuild cards</div>
      <div class="muted" style="margin-top:8px">If you change chunk sizing after importing, rebuild cards from stored docs below.</div>
      <div class="actions"><button id="rebuildAll">Rebuild cards from stored docs</button></div>
    </div>
  `;

  document.getElementById("themeToggle").onchange = (e) => {
    state.prefs.theme = e.target.checked ? "dark" : "light";
    saveState(state);
    applyTheme();
    renderAll();
  };

  document.getElementById("saveSettings").onclick = () => {
    const minV = parseInt(document.getElementById("minChunk").value, 10);
    const maxV = parseInt(document.getElementById("maxChunk").value, 10);
    const goalV = parseInt(document.getElementById("dailyGoal").value, 10);

    if (!(minV >= 150 && maxV >= 250 && minV < maxV)) { alert("Please use valid values (Min < Max)."); return; }
    if (!(goalV >= 5 && goalV <= 300)) { alert("Daily goal must be between 5 and 300."); return; }

    state.prefs.minChunkSize = minV;
    state.prefs.maxChunkSize = maxV;
    state.game.dailyGoal = goalV;

    saveState(state);
    renderAll();
  };

  document.getElementById("rebuildAll").onclick = () => {
    if (!state.docs.length) { alert("No docs stored yet."); return; }
    const keepDocs = [...state.docs];
    state.cards = [];
    for (const d of keepDocs) {
      state.cards.push(...chunkTextToCards(d.id, d.text, state.prefs.minChunkSize, state.prefs.maxChunkSize));
    }
    state.prefs.flip = false;
    saveState(state);
    renderAll();
    alert("Rebuilt cards.");
  };
}

function renderAll() {
  applyTheme();
  updateCounts();
  renderHome();
  renderStudy();
  renderQuiz();
  renderLibrary();
  renderStats();
  renderSettings();
}

// Register service worker
if ("serviceWorker" in navigator) {
  window.addEventListener("load", async () => {
    try { await navigator.serviceWorker.register("./sw.js"); } catch {}
  });
}

renderAll();
</script>
</body>
</html>
